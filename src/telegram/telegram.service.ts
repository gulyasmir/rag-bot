import { Injectable } from '@nestjs/common';
import { OpenaiService } from 'src/openai/openai.service';
import { readFileSync } from 'fs';
import * as dotenv from 'dotenv';
const TelegramBot = require('node-telegram-bot-api');
dotenv.config({ path: __dirname + '/.env' });
const token = process.env.BOT_TOKEN;
const quizeFile = process.env.QUIZE_FILE;
const questionFileName = process.env.QUESTION_FILE;
const theme = process.env.THEME;

const infoLink1 = 'https://platform.openai.com/docs/overview';
const infoLink2 = 'https://docs.pinecone.io/guides/get-started/overview';
const infoLink3 =
  'https://help.openai.com/en/articles/8868588-retrieval-augmented-generation-rag-and-semantic-search-for-gpts';

// –î–ª—è –ø—Ä–æ–¥–∞ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å WebHooks
const bot = new TelegramBot(token, { polling: true });
@Injectable()
export class TelegramService {
  private counter = 0;
  private rightAnswerCounter = 0;
  private questions: any[];
  constructor(private openaiService: OpenaiService) {}

  async run() {
    this.questions = await this.getQuestions();
    bot.setMyCommands([
      { command: '/start', description: '–ù–∞—á–Ω–µ–º!' },
      { command: '/test ', description: '–ü—Ä–æ–π—Ç–∏ —Ç–µ—Å—Ç' },
      { command: '/quiz ', description: '–ü—Ä–æ–π—Ç–∏ quiz' },
    ]);

    bot.on('message', async (msg) => {
      const text = msg.text;
      const chatId = msg.chat.id;
      try {
        if (text === '/start') {
          await this.start(chatId, msg.chat);
        } else if (text === '/test') {
          await this.test(chatId, 1);
        } else if (!text.includes('/')) {
          if (this.counter > 0) {
            await this.reply(chatId, text);
          } else {
            await this.dialog(chatId, msg);
          }
        }
      } catch (error) {
        console.error(error);
      }
    });

    bot.on('callback_query', async (query) => {
      const chatId = query.message.chat.id;
      const handlers = {
        '/about': () => this.about(chatId),
        '/info': () => this.info(chatId),
        '/quiz': () => this.quiz(chatId, 1),
        '/test': () => this.test(chatId, 1),
        '/true': () => this.good(chatId),
        '/false': () => this.bad(chatId),
        '/exit': () => this.exit(chatId),
        '/next': () => this.quiz(chatId, 2),
      };

      try {
        if (handlers[query.data]) {
          await handlers[query.data]();
        } else if (query.data.includes('/dialog#')) {
          const text = this.getAfterHashRegex(query.data);
          await this.dialog(chatId, text);
        } else if (query.data.includes('/dialogAnswer#')) {
          const text = this.getAfterHashRegex(query.data);
          await this.reply(chatId, text);
        }

        bot.answerCallbackQuery(query.id);
      } catch (error) {
        console.error(error);
      }
    });
  }

  async reply(chatId, answer) {
    const query = this.questions[this.counter].query;
    const queryAnswer = `–ù–∞ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–π –≤–æ–ø—Ä–æ—Å ${query} –±—ã–ª –¥–∞–Ω –æ—Ç–≤–µ—Ç ${answer} –≠—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –Ω–∞ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–π –≤–æ–ø—Ä–æ—Å?`;
    this.counter = 0;
    return this.dialogAnswer(chatId, queryAnswer);
  }

  getAfterHashRegex(str) {
    const match = str.match(/#(.*)/);
    if (match === null) {
      return null; // –ò–ª–∏ "" - –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
    }
    return match[1];
  }

  async exit(chatId) {
    await bot.sendMessage(
      chatId,
      `–¢—ã –º–æ–ª–æ–¥–µ—Ü! –û—Ç–≤–µ—Ç–∏–ª —Ö–æ—Ä–æ—à–æ –Ω–∞ ${this.rightAnswerCounter} –∏–∑ ${this.counter} –≤–æ–ø—Ä–æ—Å–æ–≤!`,
    );

    await bot.sendMessage(chatId, '–ü–æ–±–æ–ª—Ç–∞–µ–º?', {
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: '–î–∞!',
              callback_data: `/dialog#–Ø —Ö–æ—á—É –ø–æ–≥–æ–≤–æ—Ä–∏—Ç—å –æ ${theme}`,
            },
            {
              text: '–ù–µ—Ç',
              callback_data: `/dialog#–Ø –Ω–µ —Ö–æ—á—É –≥–æ–≤–æ—Ä–∏—Ç—å –æ ${theme}`,
            },
          ],
        ],
        one_time_keyboard: true,
        resize_keyboard: true,
      },
    });
  }

  async start(chatId, chat) {
    this.counter = 0;
    await bot.sendMessage(chatId, `–ü—Ä–∏–≤–µ—Ç, ${chat.first_name}! `, {
      parse_mode: 'HTML',
    });

    bot.sendMessage(
      chatId,
      '–ß—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —á—Ç–æ –¥–∞–ª—å—à–µ, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ',
      {
        reply_markup: {
          inline_keyboard: [
            [
              { text: '–û –±–æ—Ç–µ', callback_data: '/about' },
              { text: '–°—Å—ã–ª–∫–∏ –Ω–∞ –º–∞—Ç–µ—Ä–∏–∞–ª—ã', callback_data: '/info' },
            ],

            [{ text: '–ü–æ–≥–æ–≤–æ—Ä–∏–º?', callback_data: '/dialog#' }],
            [{ text: 'üöÄ –ü—Ä–æ–π—Ç–∏ –∫–≤–∏–∑', callback_data: '/quiz' }],
          ],
          resize_keyboard: true,
          one_time_keyboard: true,
        },
      },
    );
  }

  async awaitResponse(chatId) {
    await bot.sendChatAction(chatId, 'typing');
    await new Promise((resolve) => setTimeout(resolve, 5000));
  }

  async about(chatId) {
    console.log('about');
    this.awaitResponse(chatId);
    const aboutResponse =
      '–≠—Ç–æ—Ç –±–æ—Ç —Å–¥–µ–ª–∞–Ω –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∫–æ–¥–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ RAG –∏ OpenAI –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞ –¥–æ–æ–±—É—á–µ–Ω–æ–π –º–æ–¥–µ–ª–∏ chatGPT.\n\n–ë–æ—Ç –Ω–∞–ø–∏—Å–∞–Ω –Ω–∞ Nestjs.\n\n–ü—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤ chatGPT –≤–æ–∑–º–æ–∂–Ω—ã "–≥–∞–ª–ª—é—Ü–∏–Ω–∞—Ü–∏–∏", —Ç.–∫. –∫–æ–≥–¥–∞ –º–æ–¥–µ–ª–∏ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–≤–µ—Ç–∞ –æ–Ω–∞ –≤—ã–¥–∞–µ—Ç –æ—Ç–≤–µ—Ç –ø–æ—Ö–æ–∂–∏–π –Ω–∞ –ø—Ä–∞–≤–¥—É, –Ω–æ –Ω–µ–≤–µ—Ä–Ω—ã–π.\n\n–î–ª—è —Ä–µ—à–µ–Ω–∏—è —ç—Ç–æ–π –ø—Ä–æ–±–ª–µ–º—ã —è –∏—Å–ø–æ–ª—å–∑—É—é —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—é RAG - —Å–æ–∑–¥–∞–µ—Ç—Å—è  –≤–µ–∫—Ç–æ—Ä–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ, –∏ –æ–±—É—á–∞–µ—Ç—Å—è –∑–∞–¥–∞–Ω–Ω–æ–π —Ç–µ–º–µ. –ü—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –¥–∞–Ω–Ω—É—é —Ç–µ–º—É –∫ –∑–∞–ø—Ä–æ—Å—É –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –¥–∞–Ω–Ω—ã–µ –ø–æ —ç—Ç–æ–π —Ç–µ–º–µ –∏–∑ –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞.\n\n–í —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ OpenAI GPT (–∏–ª–∏ –¥—Ä—É–≥–∞—è –º–æ–¥–µ–ª—å) –æ—Ç–≤–µ—á–∞–µ—Ç –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ.';

    bot.sendMessage(chatId, aboutResponse, { parse_mode: 'HTML' });
  }

  async info(chatId) {
    //console.log('info');
    this.awaitResponse(chatId);
    const infoResponse = `–ù–∏–∂–µ –ø—Ä–∏–≤–µ–¥–µ–Ω—ã —Å—Å—ã–ª–∫–∏ –Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é OpenAI\n ${infoLink1}\n\nPinecone (–≤–µ–∫—Ç–æ—Ä–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–∞–Ω–Ω—ã—Ö)\n${infoLink2}\n\n –∏ –æ–ø–∏—Å–∞–Ω–∏–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ RAG\n ${infoLink3}`;

    bot.sendMessage(chatId, infoResponse, {
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [{ text: '–ü–æ–≥–æ–≤–æ—Ä–∏–º?', callback_data: '/dialog#' }],
          [{ text: 'üöÄ –ü—Ä–æ–π—Ç–∏ –∫–≤–∏–∑', callback_data: '/quiz' }],
        ],
        resize_keyboard: true,
        one_time_keyboard: true,
      },
    });
  }

  async dialog(chatId, query) {
    this.awaitResponse(chatId);
    const namespaceName = theme;
    const questionText = query.text;
    const dialogResponse = await this.openaiService.rag(namespaceName, query);
    bot.sendMessage(chatId, dialogResponse);
  }

  async dialogAnswer(chatId, query) {
    this.awaitResponse(chatId);
    const namespaceName = theme;
    const dialogResponse = await this.openaiService.ragAswer(
      namespaceName,
      query,
    );
    bot.sendMessage(chatId, dialogResponse);
  }

  async getQuestions() {
    const rawData = readFileSync(questionFileName, 'utf-8');
    const questions = JSON.parse(rawData);
    return questions;
  }

  async test(chatId, call) {
    const questCount = 10;
    const questions: any[] = this.questions;
    if (call == 1) {
      bot.sendMessage(chatId, '–ü—Ä–∏–≤–µ—Ç! –î–∞–≤–∞–π –Ω–∞—á–Ω–µ–º –≤–∏–∫—Ç–æ—Ä–∏–Ω—É!');
      await this.delay();
    }

    const number = Math.floor(Math.random() * questCount - 1) + 1; // –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –≤–æ–ø—Ä–æ—Å–æ–≤ –≤ chatGPT –±—É–¥–µ—Ç –≤—ã–±–∏—Ä–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –∏–∑ 10 –≤–æ–ø—Ä–æ—Å–æ–≤.
    const question = questions[number];
    this.counter = number;
    await bot.sendMessage(chatId, question.query);
  }

  async getQuiz() {
    const rawData = readFileSync(quizeFile, 'utf-8');
    const quiz = JSON.parse(rawData);

    const questions: any[] = quiz;
    const transformedQuestions: any[] = questions.map((question) => {
      const correctAnswer = question.answer.split('.')[0];
      const otherQuestions = questions.filter((q) => q.id !== question.id);
      const incorrectAnswers = otherQuestions
        .slice(0, 2)
        .map((q) => q.answer.split('.')[0]);

      // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–∞
      const options = [
        [{ text: incorrectAnswers[0], callback_data: '/false' }],
        [{ text: correctAnswer, callback_data: '/true' }],
        [{ text: incorrectAnswers[1], callback_data: '/false' }],
      ];

      // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –ø–æ—Ä—è–¥–æ–∫ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –æ—Ç–≤–µ—Ç–∞
      for (let i = options.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [options[i], options[j]] = [options[j], options[i]];
      }

      return {
        query: question.query,
        correctAnswer: correctAnswer,
        options: options,
      };
    });
    return transformedQuestions;
  }

  async quiz(chatId, call) {
    const questCount = 10;
    const questions: any[] = await this.getQuiz();
    if (call == 1) {
      bot.sendMessage(chatId, '–ü—Ä–∏–≤–µ—Ç! –î–∞–≤–∞–π –Ω–∞—á–Ω–µ–º!');
      await this.delay();
    }

    const number = Math.floor(Math.random() * questCount - 1) + 1; // –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –≤–æ–ø—Ä–æ—Å–æ–≤ –≤ chatGPT –±—É–¥–µ—Ç –≤—ã–±–∏—Ä–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –∏–∑ 10 –≤–æ–ø—Ä–æ—Å–æ–≤.

    const question = questions[number];

    await bot.sendMessage(chatId, question.query, {
      reply_markup: {
        inline_keyboard: question.options,
        one_time_keyboard: true,
        resize_keyboard: true,
      },
    });
    await new Promise((resolve) => setTimeout(resolve, 5000));
  }
  async good(chatId) {
    this.counter++;
    this.rightAnswerCounter++;
    bot.sendMessage(
      chatId,
      '–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç! –î–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–π–¥–µ–º –∫–æ —Å–ª–µ–¥—É—é—â–µ–º—É –≤–æ–ø—Ä–æ—Å—É.',
      {
        reply_markup: {
          inline_keyboard: [
            [
              { text: '–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å', callback_data: '/next' },
              { text: '–ó–∞–∫–æ–Ω—á–∏—Ç—å', callback_data: '/exit' },
            ],
          ],
          one_time_keyboard: true,
          resize_keyboard: true,
        },
      },
    );
  }

  async bad(chatId) {
    this.counter++;
    bot.sendMessage(chatId, `–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç.`, {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å', callback_data: '/next' },
            { text: '–ó–∞–∫–æ–Ω—á–∏—Ç—å', callback_data: '/exit' },
          ],
        ],
        one_time_keyboard: true,
        resize_keyboard: true,
      },
    });
  }

  async sendError(chatId) {
    await bot.sendMessage(chatId, `–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫`);
  }

  delay() {
    const randomTime = this.getRandomMilliseconds();
    return new Promise((resolve) => setTimeout(resolve, 1500));
  }

  getRandomMilliseconds(): number {
    const minMilliseconds = 0.1 * 60 * 1000;
    const maxMilliseconds = 0.2 * 60 * 1000;
    const randomMilliseconds =
      Math.floor(Math.random() * (maxMilliseconds - minMilliseconds + 1)) +
      minMilliseconds;

    return randomMilliseconds;
  }
}
